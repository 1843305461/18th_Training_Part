## Week 5

说明：本文档主要是将晦涩难懂的官方语言尽量解释成大家可以理解的知识，但这也意味着这种解释是片面的，所以大家在观看完本文档后，应该对TIM，UART等功能有大体的认识，在基于这种认识之上，再去学习官方对于各种功能的解释，就会比较好理解了。所以要求大家在观看完本文档后，开始自学，在网络上查找本周涉及到的相关知识，比如CSDN，有很多大佬写的博客，但这些博客对于新手来说确实有一些难懂，所以要求大家观看完本文档，在CSDN（或其他平台）上查找相关知识，进一步的学习。同时学明白原理之后，也要明白代码如何配置相关功能，大家可以参考**正点原子**，**野火**等相关例程。

### 高级TIM

在上周大家已经了解了定时器的初级功能，比如定时器中断，计数。在这周大家会学习定时器其他功能。![](https://cdn.jsdelivr.net/gh/yiming-gu/blogImage@main/img/20200508202457535.png)

在了解定时器的功能之前，大家先了解一下定时器的原理，定时器就是每隔设定的时间增1，你可以通过设定定时器的频率来设定定时器增1的周期，比如设定2000Hz，就是1秒钟计两千次。计的数是储存在叫TIMx_CNT寄存器中的，这个寄存器的大小是16位或32位，也就是计数器计数的最大值是65535，当计数计满后会发生溢出事件（当然这个计数计满的值也可以人为设定，可以触发中断/DMA），自动从重装载值开始重新计数。如何设定定时器的频率，这就涉及到另一个寄存器TIMx_PSC，这个寄存器可以设置定时器频率的预分频系数。定时器频率=72MHZ/(时钟预分频+1)，溢出时间=(时钟预分频+1)\* (TIM_Period（上文计数器计满的值）+1)/72MHZ。或者你可以不设定计数器计满的值，也可以设定计数器计数的初始值（通过重装载寄存器），或者两个都设定。目的都是设定定时器计数多少触发溢出事件。**注意，预分频系数是你设定的值+1，计数器计满的值也是你设定的值+1。**

#### 输入捕获

字面意思上就是捕获输入信号，所以它捕获的就是定时器对应通道的上升沿或者下降沿，它将通道出现上升沿时刻，当时定时器的计数值存储到对应的通道的捕获/比较寄存器（TIMx_CCRx）里面，完成一次捕获，并且可以触发中断。

#### 输出比较

我们既然可以记录通道输入信号的时间，也可以通过时间控制通道的输出，比如让单片机在某个时间段内输出低电平，在另个时间段内输出高电平。我们使用这个功能最重要的就是让单片机输出PWM波，我们使用PWM作为控制信号来使用，一般来调节它的占空比来进行电机，舵机的控制。在之前我们已经学习了PWM，我们可以通过TIM的功能产生PWM信号。![](https://cdn.jsdelivr.net/gh/yiming-gu/blogImage@main/img/20200605090201540.png)

其实它是设定了一个计数值，计数器有向上计数，向下计数，中心对齐三种计数模式，通过你设定的计数值，并且可以设定高于设定值，定时器的通道就输出高电平或低电平，低于设定值，定时器的通道输出相反的电平。这个设定值也是通过设定捕获/比较寄存器中的值实现的。所以大家明白为什么叫做输出比较了吧，原理就是定时器的计数值和你设定的值进行比较，从而可以输出不同的电平。

那么涉及到了PWM，它的最重要的两个参数，频率和占空比，那么我们如何通过设定输出比较设定值和定时器的计数频率，计数计满的值来调整这两个参数呢，比如我们上文已经向上计数的PWM波产生的方式，以它为例，怎么调整它的频率和占空比呢？定时器向上计数计到满就是PWM的一个周期，所以我们可以设定比较值在0-计数器计满值的范围，来设定占空比。比如定时器计满的值是100，比较值在0-100范围内，如果比较值是50，就是0-50范围内输出高电平（也可以输出低电平），那它占空比就是50%。那么我们怎么改变它的频率，我们已经知道定时器计数计到满就是一个周期，那么我们就可以改变定时器计数溢出的时间改变频率，也就是改变周期。那么怎么改变定时器的计数溢出时间，你可以改变定时器计一次数的时间或者改变计数溢出的范围（也就是PSC与CNT两个寄存器）。

#### 编码器模式

STM32的定时器还拥有编码器模式，它对于AB相编码器

### UART

我们使用串口最多的就是进行调试工作，通过串口返回一些重要的参数，把这些参数绘制成图像方便我们进行观察，调试参数。

推荐大家下载一个vofa+。它可以将串口返回的值实时画出来，非常的好用。

下载地址：[VOFA+ | VOFA+](https://www.vofa.plus/)

首先，串口最为一种通信协议，我们需要先了解它是如何进行通信的。

UART，全双工通用异步收发串行器，它的工作原理是将数据的二进制位一位一位串行传输，在UART通讯协议中信号线上的状态位高电平代表’1’低电平代表’0’。当然两个设备使用UART串口通讯时，必须先约定好传输速率和一些数据位。全双工代表了可以同时进行接受和发送数据，异步代表不需要同步时钟

硬件连接比较简单，仅需要3条线，**注意连接时两个设备UART电平，如电平范围不一致请做电平转换后再连接**，如下图所示：

- TX：发送数据端，要接对面设备的RX
- RX：接收数据端，要接对面设备的TX
- GND：保证两设备共地，有统一的参考平面

![](https://cdn.jsdelivr.net/gh/yiming-gu/blogImage@main/img/20181225114440688.jpg)

UART作为异步[串口](https://so.csdn.net/so/search?q=串口&spm=1001.2101.3001.7020)通信协议的一种，工作原理是将数据的字节一位接一位地传输。协议如下：

![](https://cdn.jsdelivr.net/gh/yiming-gu/blogImage@main/img/20181226094646598.png)

**空闲位：**
UART协议规定，当总线处于空闲状态时信号线的状态为‘1’即高电平
**起始位：**
开始进行数据传输时发送方要先发出一个低电平’0’来表示传输字符的开始。因为空闲位一直是高电平所以开始第一次通讯时先发送一个明显区别于空闲状态的信号即为低电平。
**数据位：**
起始位之后就是要传输的数据，数据可以是5，6，7，8，9位，构成一个字符，一般都是8位。先发送最低位最后发送最高位。
**奇偶校验位：**
数据位传送完成后，要进行奇偶校验，校验位其实是调整个数，串口校验分几种方式：
1.无校验（no parity）
2.奇校验（odd parity）：如果数据位中’1’的数目是偶数，则校验位为’1’，如果’1’的数目是奇数，校验位为’0’。
3.偶校验（even parity）：如果数据为中’1’的数目是偶数，则校验位为’0’，如果为奇数，校验位为’1’。
4.mark parity：校验位始终为1
5.space parity：校验位始终为0
**停止位：**
数据结束标志，可以是1位，1.5位，2位的高电平。
**波特率：**
数据传输速率使用波特率来表示，单位bps（bits per second），常见的波特率9600bps，115200bps等等，其他标准的波特率是1200，2400，4800，19200，38400，57600。举个例子，如果串口波特率设置为9600bps，那么传输一个比特需要的时间是1/9600≈104.2us。

以9600波特率，8个数据位，没有校验位，1位停止位为例，这是目前最常用的串口配置，现在我们传输’O’'K’两个ASCII值，'O’的ASCII为79，对应的二进制数据为01001111 ，'K’对应的二进制数据为01001011 ，传输的格式数据如下图所示：

![](https://cdn.jsdelivr.net/gh/yiming-gu/blogImage@main/img/20181226100234335.png)

串口波特率为9600，1bit传输时间大约为104us，传送一个数据实际是10个比特（开始位，8个数据位，停止位），一个bytes传输速率实际为9600*8/10=7680bps。

那么我们怎么使用STM32实现UART，我们将UART初始化后，UART收到的值会存在寄存器内，我们直接读取就可以，发送数据也是直接向相关寄存器中写值就可以。我们一般使用到的功能就是单片机向电脑发送数据，向寄存器中写值太麻烦了，有没有更简单的方式呢。有，在C语言中我们学习过printf打印数据，那嵌入式C语言中我们可以重定向printf，直接使用printf来控制串口输出数据。重定向方式在正点原子，野火的例程中都存在。

```c
//重定义fputc函数 
int fputc(int ch, FILE *f)
{ 	
	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
	USART1->DR = (u8) ch;      
	return ch;
}
```

重定向后我们就可以使用printf通过串口发送数据。

### ADC DAC

大家都知道信息在电脑的世界里都是二进制的，也就是数字量，数字量在时间上是不连续的，模拟量在时间上是连续的，比如7用二进制表示是0111，8用二进制表示是1000，但7.5怎么表示，是无法表示的，这时你的有人会说计算机里不也有float类型吗，但这只是精度更高而已，你实际采集到的信息可能是无限不循环小数。我们要采集外界信息，就必须把收集到的模拟量转换为数字量，这种转换就用到了ADC和DAC，ADC将模拟量转换为数字量，DAC将数字量转换为模拟量。

STM32支持12位的ADC，意味着它可以将引脚的0-3V3电压转换成0-4095范围内，你只需要在程序内进行转换就可以得知引脚的电压是多少。

DAC与ADC相反，是将数字量转换为模拟量。